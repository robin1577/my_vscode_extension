{
    "if": {
		"prefix": "if",
		"body": [
			"if (${1:test}) {",
			"\t$0",
			"}"
		],
		"description": "for 循环"
	},
	"if else": {
		"prefix": "if else",
		"body": [
			"if (${test}) {",
			"\t$0",
			"} else {",
			"\t",
			"}"
		]
	},
	"if else if": {
		"prefix": "if elsif",
		"body": [
			"if (${1:test}) {",
			"\t$0",
			"} else if () {",
			"\t",
			"}"
		]
	},
	"try catch": {
		"prefix": "try catch",
		"body": [
			"try {",
			"\t$0",
			"} catch {",
			"\t",
			"}"
		]
	},
	"APPLET_SHELLCODE_FORMAT" : {
		"description": "Format shellcode before it's placed on the HTML page generated to serve the Signed or Smart Applet Attacks.",
		"prefix": "APPLET_SHELLCODE_FORMAT",
		"body": [
			"set APPLET_SHELLCODE_FORMAT {",
			"\t\\$shellcode = \\$1;",
			"\t$0",
			"}"
		]
	},
	"EXECUTABLE_ARTIFACT_GENERATOR" : {
		"description": "Control the EXE and DLL generation for Cobalt Strike",
		"prefix": "EXECUTABLE_ARTIFACT_GENERATOR",
		"body": [
			"set EXECUTABLE_ARTIFACT_GENERATOR {",
			"\t\\$artefact = \\$1;",
			"\t\\$shellcode = \\$2;",
			"\t$0",
			"}"
		]
	},
	"HTMLAPP_EXE" : {
		"description": "Controls the content of the HTML Application User-driven (EXE Output) generated by Cobalt Strike",
		"prefix": "HTMLAPP_EXE",
		"body": [
			"set HTMLAPP_EXE {",
			"\t\\$exe = \\$1;",
			"\t\\$name = \\$2;",
			"\t$0",
			"}"
		]
	},
	"HTMLAPP_POWERSHELL" : {
		"description": "Controls the content of the HTML Application User-driven (PowerShell Output) generated by Cobalt Strike",
		"prefix": "HTMLAPP_POWERSHELL",
		"body": [
			"set HTMLAPP_POWERSHELL {",
			"\t\\$command = \\$1;",
			"\t$0",
			"}"
		]
	},
	"POWERSHELL_COMMAND" : {
		"description": "Change the form of the powershell comamnd run by Cobalt Strike's automation. This affects jump psexec_psh, powershell, and [host] -> Access -> One-liner.",
		"prefix": "POWERSHELL_COMMAND",
		"body": [
			"set POWERSHELL_COMMAND {",
			"\t\\$command = \\$1;",
			"\t\\$remote = \\$2;",
			"\t$0",
			"}"
		]
	},
	"POWERSHELL_COMPRESS": {
		"description": "A hook used by the resource kit to compress a PowerShell script. The default uses gzip and returns a deflator script.",
		"prefix": "POWERSHELL_COMPRESS",
		"body": [
			"set POWERSHELL_COMPRESS {",
			"\t\\$script = \\$1;",
			"\t$0",
			"}"
		]
	},
	"POWERSHELL_DOWNLOAD_CRADLE": {
		"description": "Change the form of the PowerShell download cradle used in Cobalt Strike's post-ex automation. This includes jump winrm|winrm64, [host] -> Access -> One Liner, and powershell-import.",
		"prefix": "POWERSHELL_DOWNLOAD_CRADLE",
		"body": [
			"set POWERSHELL_DOWNLOAD_CRADLE {",
			"\t\\$url = \\$1;",
			"\t$0",
			"}"
		]
	},
	"PSEXEC_SERVICE": {
		"description": "Set the service name used by jump psexec|psexec64|psexec_psh and psexec.",
		"prefix": "PSEXEC_SERVICE",
		"body": [
			"set PSEXEC_SERVICE {",
			"\t$0",
			"}"
		]
	},
	"PYTHON_COMPRESS": {
		"description": "Compress a Python script generated by Cobalt Strike.",
		"prefix": "PYTHON_COMPRESS",
		"body": [
			"set PYTHON_COMPRESS {",
			"\t\\$script = \\$1;",
			"\t$0",
			"}"
		]
	},
	"RESOURCE_GENERATOR": {
		"description": "Control the format of the VBS template used in Cobalt Strike.",
		"prefix": "RESOURCE_GENERATOR",
		"body": [
			"set RESOURCE_GENERATOR {",
			"\t\\$shellcode = \\$1;",
			"\t$0",
			"}"
		]
	},
	"RESOURCE_GENERATOR_VBS": {
		"description": "Controls the content of the HTML Application User-driven (EXE Output) generated by Cobalt Strike.",
		"prefix": "RESOURCE_GENERATOR_VBS",
		"body": [
			"set RESOURCE_GENERATOR_VBS {",
			"\t\\$exe = \\$1;",
			"\t\\$name = \\$2;",
			"\t$0",
			"}"
		]
	},
	"SIGNED_APPLET_MAINCLASS": {
		"description": "Specify the MAIN class of the Java Signed Applet Attack.",
		"prefix": "SIGNED_APPLET_MAINCLASS",
		"body": [
			"set SIGNED_APPLET_MAINCLASS {",
			"\t$0",
			"}"
		]
	},
	"SIGNED_APPLET_RESOURCE": {
		"description": "Specify a Java Applet file to use for the Java Signed Applet Attack.",
		"prefix": "SIGNED_APPLET_RESOURCE",
		"body": [
			"set SIGNED_APPLET_RESOURCE {",
			"\t$0",
			"}"
		]
	},
	"SMART_APPLET_MAINCLASS": {
		"description": "Specify the MAIN class of the Java Smart Applet Attack.",
		"prefix": "SMART_APPLET_MAINCLASS",
		"body": [
			"set SMART_APPLET_MAINCLASS {",
			"\t$0",
			"}"
		]
	},
	"SMART_APPLET_RESOURCE": {
		"description": "Specify a Java Applet file to use for the Java Smart Applet Attack",
		"prefix": "SMART_APPLET_RESOURCE",
		"body": [
			"set SMART_APPLET_RESOURCE {",
			"\t$0",
			"}"
		]
	},
	"-is64": {
		"description": "Check if a session is on an x64 system or not (Beacon only).",
		"prefix": "-is64",
		"body": [
			"-is64 $0${1:beacon}"
		]
	},
	"-isactive": {
		"description": "Check if a session is active or not. A session is considered active if (a) it has not acknowledged an exit message AND (b) it is not disconnected from a parent Beacon.",
		"prefix": "-isactive",
		"body": [
			"-isactive $0${1:beacon}"
		]
	},
	"-isadmin": {
		"description": "Check if a session has admin rights",
		"prefix": "-isadmin",
		"body": [
			"-isadmin $0${1:beacon}"
		]
	},
	"-isbeacon": {
		"description": "Check if a session is a Beacon or not.",
		"prefix": "-isbeacon",
		"body": [
			"-isbeacon $0${1:beacon}"
		]
	},
	"-isssh": {
		"description": "Check if a session is an SSH session or not.",
		"prefix": "-isssh",
		"body": [
			"-isssh $0${1:beacon}"
		]
	},
	"action": {
		"description": "Post a public action message to the event log. This is similar to the /me command.",
		"prefix": "action",
		"body": [
			"action($0${1:message})"
		]
	},
	"addTab": {
		"description": "Create a tab to display a GUI object",
		"prefix": "addTab",
		"body": [
			"addTab($0${1:title}, ${2:object}, ${3:tooltip})"
		]
	},
	"addVisualization": {
		"description": "Register a visualization with Cobalt Strike",
		"prefix": "addVisualization",
		"body": [
			"addVisualization($0${1:name}, ${2:object})"
		]
	},
	"add_to_clipboard": {
		"description": "Add text to the clipboard, notify the user",
		"prefix": "add_to_clipboard",
		"body": [
			"add_to_clipboard($0${1:text})"
		]
	},
	"alias": {
		"description": "Creates an alias command in the Beacon console",
		"prefix": "alias",
		"body": [
			"alias($0${1:name}, {",
			"\t${2:callback}",
			"});"
		]
	},
	"alias_clear": {
		"description": "Removes an alias command (and restores default functionality if it existed)",
		"prefix": "alias_clear",
		"body": [
			"alias_clear($0${1:alias})"
		]
	},
	"applications": {
		"description": "Returns a list of application information in Cobalt Strike's data model. These applications are results from the System Profiler",
		"prefix": "applications",
		"body": [
			"foreach $index => $entry (applications()) {",
			"\t$0",
			"}"
		]
	},
	"archives": {
		"description": "Returns a massive list of archived information about your activity from Cobalt Strike's data model. This information is leaned on heavily to reconstruct your activity timeline in Cobalt Strike's reports.",
		"prefix": "archives",
		"body": [
			"foreach $index => $entry (archives()) {",
			"\t$0",
			"}"
		]
	},
	"artifact_general": {
		"description": "Generates a payload artifact from arbitrary shellcode",
		"prefix": "artifact_general",
		"body": [
			"$artifact_general($0${1:shellcode}, ${2:type}, ${3:architecture})"
		]
	},
	"artifact_payload": {
		"description": "Generates a stageless payload artifact (exe, dll) from a Cobalt Strike listener name",
		"prefix": "artifact_payload",
		"body": [
			"artifact_payload($0${1:listener}, ${2:type}, ${3:architecture})"
		]
	},
	"artifact_sign": {
		"description": "Sign an EXE or DLL file",
		"prefix": "artifact_sign",
		"body": [
			"artifact_sign($0${1:artefact})"
		]
	},
	"artifact_stager": {
		"description": "Generates a stager artifact (exe, dll) from a Cobalt Strike listener",
		"prefix": "artifact_stager",
		"body": [
			"artifact_stager($0${1:listener}, ${2:type}, ${3:architecture})"
		]
	},
	"barch": {
		"description": "Returns the architecture of your Beacon session (e.g., x86 or x64)",
		"prefix": "barch",
		"body": [
			"barch($0${1:beacon})"
		]
	},
	"bargue_add": {
		"description": "This function adds an option to Beacon's list of commands to spoof arguments for.",
		"prefix": "bargue_add",
		"body": [
			"bargue_add($0${1:beacon}, ${2:command}, ${3:arguments})"
		]
	},
	"bargue_list": {
		"description": "List the commands + fake arguments Beacon will spoof arguments for",
		"prefix": "bargue_list",
		"body": [
			"bargue_list($0${1:beacon})"
		]
	},
	"bargue_remove": {
		"description": "This function removes an option to Beacon's list of commands to spoof arguments for.",
		"prefix": "bargue_remove",
		"body": [
			"bargue_remove($0${1:beacon}, ${2:command})"
		]
	},
	"base64_decode": {
		"description": "Unwrap a base64-encoded string",
		"prefix": "base64_decode",
		"body": [
			"base64_decode($0${1:string})"
		]
	},
	"base64_encode": {
		"description": "Base64 encode a string",
		"prefix": "base64_encode",
		"body": [
			"base64_encode($0${1:string})"
		]
	},
	"bblockdlls": {
		"description": "Launch child processes with binary signature policy that blocks non-Microsoft DLLs from loading in the process space",
		"prefix": "bblockdlls",
		"body": [
			"bblockdlls($0${1:beacon}, ${2:boolean})"
		]
	},
	"bbrowser": {
		"description": "Generate the beacon browser GUI component. Shows only Beacons.",
		"prefix": "bbrowser",
		"body": [
			"bbrowser()"
		]
	},
	"bbrowserpivot": {
		"description": "Start a Browser Pivot",
		"prefix": "bbrowserpivot",
		"body": [
			"bbrowserpivot($0${1:beacon}, ${2:pid}, ${3:architecture})"
		]
	},
	"bbrowserpivot_stop": {
		"description": "Stop a Browser Pivot",
		"prefix": "bbrowserpivot_stop",
		"body": [
			"bbrowserpivot_stop($0${1:beacon})"
		]
	},
	"bcancel": {
		"description": "Cancel a file download",
		"prefix": "bcancel",
		"body": [
			"bcancel($0${1:beacon}, ${2:file})"
		]
	},
	"bcd": {
		"description": "Ask a Beacon to change it's current working directory",
		"prefix": "bcd",
		"body": [
			"bcd($0${1:beacon}, ${2:path})"
		]
	},
	"bcheckin": {
		"description": "Ask a Beacon to checkin. This is basically a no-op for Beacon",
		"prefix": "bcheckin",
		"body": [
			"bcheckin($0${1:beacon})"
		]
	},
	"bclear": {
		"description": "This is the \"oops\" command. It clears the queued tasks for the specified beacon",
		"prefix": "bclear",
		"body": [
			"bclear($0${1:beacon})"
		]
	},
	"bconnect": {
		"description": "Ask Beacon (or SSH session) to connect to a Beacon peer over a TCP socket",
		"prefix": "bconnect",
		"body": [
			"bconnect($0${1:beacon}, ${2:target}, [${3:port}])"
		]
	},
	"bcovertvpn": {
		"description": "Ask Beacon to deploy a Covert VPN client",
		"prefix": "bcovertvpn",
		"body": [
			"bcovertvpn($0${1:beacon}, ${2:interface}, ${3:ip}, [${4:mac}])"
		]
	},
	"bcp": {
		"description": "Ask Beacon to copy a file or folder",
		"prefix": "bcp",
		"body": [
			"bcp($0${1:beacon}, ${2:source}, ${3:destination})"
		]
	},
	"bdata": {
		"description": "Get metadata for a Beacon session",
		"prefix": "bdata",
		"body": [
			"bdata($0${1:beacon})"
		]
	},
	"bdcsync": {
		"description": "Use mimikatz's dcsync command to pull a user's password hash from a domain controller",
		"prefix": "bdcsync",
		"body": [
			"bdcsync($0${1:beacon}, ${2:fqdn}, [${3:account}])"
		]
	},
	"bdesktop": {
		"description": "Start a VNC session",
		"prefix": "bdesktop",
		"body": [
			"bdesktop($0${1:beacon})"
		]
	},
	"bdllinject": {
		"description": "Inject a Reflective DLL into a process",
		"prefix": "bdllinject",
		"body": [
			"bdllinject($0${1:beacon}, ${2:pid}, ${3:dll})"
		]
	},
	"bdllload": {
		"description": "Call LoadLibrary() in a remote process with the specified DLL.",
		"prefix": "bdllload",
		"body": [
			"bdllload($0${1:beacon}, ${2:pid}, ${3:dll})"
		]
	},
	"bdllspawn": {
		"description": "Spawn a Reflective DLL as a Beacon post-exploitation job",
		"prefix": "bdllspawn",
		"body": [
			"bdllspawn($0${1:beacon}, ${2:path}, ${3:parameter}, ${4:description}, ${5:milliseconds}, ${6:boolean})"
		]
	},
	"bdownload": {
		"description": "Ask a Beacon to download a file",
		"prefix": "bdownload",
		"body": [
			"bdownload($0${1:beacon}, ${2:file})"
		]
	},
	"bdrives": {
		"description": "Ask Beacon to list the drives on the compromised system",
		"prefix": "bdrives",
		"body": [
			"bdrives($0${1:beacon})"
		]
	},
	"beacon_command_describe": {
		"description": "Describe a Beacon command",
		"prefix": "beacon_command_describe",
		"body": [
			"beacon_command_describe($0${1:beacon})"
		]
	},
	"beacon_command_detail": {
		"description": "Get the help information for a Beacon command",
		"prefix": "beacon_command_detail",
		"body": [
			"beacon_command_detail($0${1:beacon})"
		]
	},
	"beacon_command_register": {
		"description": "Register help information for a Beacon command",
		"prefix": "beacon_command_register",
		"body": [
			"beacon_command_register($0${1:command}, ${2:description}, ${3:help})"
		]
	},
	"beacon_commands": {
		"description": "Get a list of Beacon commands",
		"prefix": "beacon_commands",
		"body": [
			"beacon_commands()"
		]
	},
	"beacon_data": {
		"description": "Get metadata for a Beacon session",
		"prefix": "beacon_data",
		"body": [
			"beacon_data($0${1:beacon})"
		]
	},
	"beacon_elevator_describe": {
		"description": "Describe a Beacon command elevator exploit",
		"prefix": "beacon_elevator_describe",
		"body": [
			"beacon_elevator_describe($0${1:exploit})"
		]
	},
	"beacon_elevator_register": {
		"description": "Register a Beacon command elevator with Cobalt Strike. This adds an option to the runasadmin command",
		"prefix": "beacon_elevator_register",
		"body": [
			"beacon_elevator_register($0${1:name}, ${2:description}, ${3:function})"
		]
	},
	"beacon_elevators": {
		"description": "Get a list of command elevator exploits registered with Cobalt Strike",
		"prefix": "beacon_elevators",
		"body": [
			"beacon_elevators()"
		]
	},
	"beacon_execute_job": {
		"description": "Run a command and report its output to the user",
		"prefix": "beacon_execute_job",
		"body": [
			"beacon_elevator_register($0${1:beacon}, ${2:command}, ${3:arguments}, ${4:flags})"
		]
	},
	"beacon_exploit_describe": {
		"description": "Describe a Beacon exploit",
		"prefix": "beacon_exploit_describe",
		"body": [
			"beacon_exploit_describe($0${1:exploit})"
		]
	},
	"beacon_exploit_register": {
		"description": "Register a Beacon privilege escalation exploit with Cobalt Strike. This adds an option to the elevate command",
		"prefix": "beacon_exploit_register",
		"body": [
			"beacon_exploit_register($0${1:name}, ${2:description}, ${3:function})"
		]
	},
	"beacon_exploits": {
		"description": "Get a list of privilege escalation exploits registered with Cobalt Strike",
		"prefix": "beacon_exploits",
		"body": [
			"beacon_exploits()"
		]
	},
	"beacon_host_imported_script": {
		"description": "Locally host a previously imported PowerShell script within Beacon and return a short script that will download and invoke this script",
		"prefix": "beacon_host_imported_script",
		"body": [
			"beacon_host_imported_script($0${1:beacon})"
		]
	},
	"beacon_host_script": {
		"description": "Locally host a PowerShell script within Beacon and return a short script that will download and invoke this script. This function is a way to run large scripts when there are constraints on the length of your PowerShell one-liner",
		"prefix": "beacon_host_script",
		"body": [
			"beacon_host_script($0${1:beacon}, ${2:script})"
		]
	},
	"beacon_ids": {
		"description": "Get the ID of all Beacons calling back to this Cobalt Strike team server",
		"prefix": "beacon_ids",
		"body": [
			"beacon_ids()"
		]
	},
	"beacon_info": {
		"description": "Get information from a Beacon session's metadata",
		"prefix": "beacon_info",
		"body": [
			"beacon_info($0${1:beacon}, ${2:key})"
		]
	},
	"beacon_link": {
		"description": "This function links to an SMB or TCP listener. If the specified listener is not an SMB or TCP listener, this function does nothing",
		"prefix": "beacon_link",
		"body": [
			"beacon_link($0${1:beacon}, ${2:target}, ${2:listener})"
		]
	},
	"beacon_remote_exec_method_describe": {
		"description": "Describe a Beacon remote execute method",
		"prefix": "beacon_remote_exec_method_describe",
		"body": [
			"beacon_remote_exec_method_describe($0${1:method})"
		]
	},
	"beacon_remote_exec_method_register": {
		"description": "Register a Beacon remote execute method with Cobalt Strike. This adds an option for use with the remote-exec command",
		"prefix": "beacon_remote_exec_method_register",
		"body": [
			"beacon_remote_exec_method_register($0${1:beacon}, ${2:description}, ${3:function})"
		]
	},
	"beacon_remote_exec_methods": {
		"description": "Get a list of remote execute methods registered with Cobalt Strike",
		"prefix": "beacon_remote_exec_methods",
		"body": [
			"beacon_remote_exec_methods()"
		]
	},
	"beacon_remote_exploit_arch": {
		"description": "Get the arch info for this Beacon lateral movement option",
		"prefix": "beacon_remote_exploit_arch",
		"body": [
			"beacon_remote_exploit_arch($0${1:method})"
		]
	},
	"beacon_remote_exploit_describe": {
		"description": "Describe a Beacon lateral movement option",
		"prefix": "beacon_remote_exploit_describe",
		"body": [
			"beacon_remote_exploit_describe($0${1:method})"
		]
	},
	"beacon_remote_exploit_register": {
		"description": "Register a Beacon lateral movement option with Cobalt Strike. This function extends the jump command",
		"prefix": "beacon_remote_exploit_register",
		"body": [
			"beacon_remote_exploit_register($0${1:name}, ${2:architecture}, ${3:description}, ${4:function})"
		]
	},
	"beacon_remote_exploits": {
		"description": "Get a list of lateral movement options registered with Cobalt Strike",
		"prefix": "beacon_remote_exploits",
		"body": [
			"beacon_remote_exploits()"
		]
	},
	"beacon_remove": {
		"description": "Remove a Beacon from the display",
		"prefix": "beacon_remove",
		"body": [
			"beacon_remove($0${1:beacon})"
		]
	},
	"beacon_stage_pipe": {
		"description": "This function handles the staging process for a bind pipe stager. This is an optional stager for lateral movement. You can stage any x86 payload/listener through this stager. Use &stager_bind_pipe to generate this stager",
		"prefix": "beacon_stage_pipe",
		"body": [
			"beacon_stage_pipe($0${1:beacon}, ${2:target}, ${3:listener}, ${4:architecture})"
		]
	},
	"beacon_stage_tcp": {
		"description": "This function handles the staging process for a bind TCP stager. This is the preferred stager for localhost-only staging. You can stage any payload/listener through this stager. Use &stager_bind_tcp to generate this stager",
		"prefix": "beacon_stage_tcp",
		"body": [
			"beacon_stage_tcp($0${1:beacon}, $null, ${2:port}, ${3:listener}, ${4:architecture})"
		]
	},
	"beacons": {
		"description": "Get information about all Beacons calling back to this Cobalt Strike team server",
		"prefix": "beacons",
		"body": [
			"foreach $beacon (beacons()) {",
			"\t$0",
			"}"
		]
	},
	"belevate": {
		"description": "Ask Beacon to spawn an elevated session with a registered technique",
		"prefix": "belevate",
		"body": [
			"beacon_stage_pipe($0${1:beacon}, ${2:exploit}, ${3:target})"
		]
	},
	"belevate_command": {
		"description": "Ask Beacon to run a command in a high-integrity context",
		"prefix": "belevate_command",
		"body": [
			"belevate_command($0${1:beacon}, ${2:module}, ${3:command})"
		]
	},
	"berror": {
		"description": "Publish an error message to the Beacon transcript",
		"prefix": "berror",
		"body": [
			"berror($0${1:beacon}, ${2:message})"
		]
	},
	"bexecute": {
		"description": "Ask Beacon to execute a command [without a shell]. This provides no output to the user",
		"prefix": "bexecute",
		"body": [
			"bexecute($0${1:beacon}, ${2:command})"
		]
	},
	"bexecute_assembly": {
		"description": "Spawns a local .NET executable assembly as a Beacon post-exploitation job",
		"prefix": "bexecute_assembly",
		"body": [
			"bexecute($0${1:beacon}, ${2:assembly}, ${3:parameters})"
		]
	},
	"bexit": {
		"description": "Ask a Beacon to exit",
		"prefix": "bexit",
		"body": [
			"bexit($0${1:beacon})"
		]
	},
	"bgetprivs": {
		"description": "Attempts to enable the specified privilege in your Beacon session",
		"prefix": "bgetprivs",
		"body": [
			"bgetprivs($0${1:beacon}, ${2:privs})"
		]
	},
	"bgetsystem": {
		"description": "Ask Beacon to attempt to get the SYSTEM token.",
		"prefix": "bgetsystem",
		"body": [
			"bgetsystem($0${1:beacon})"
		]
	},
	"bgetuid": {
		"description": "Ask Beacon to print the User ID of the current token",
		"prefix": "bgetuid",
		"body": [
			"bgetuid($0${1:beacon})"
		]
	},
	"bhashdump": {
		"description": "Ask Beacon to dump local account password hashes",
		"prefix": "bhashdump",
		"body": [
			"bhashdump($0${1:beacon})"
		]
	},
	"binfo": {
		"description": "Get information from a Beacon session's metadata",
		"prefix": "binfo",
		"body": [
			"binfo($0${1:beacon}, ${2:key})"
		]
	},
	"binject": {
		"description": "Ask Beacon to inject a session into a specific process",
		"prefix": "binject",
		"body": [
			"binject($0${1:beacon}, ${2:pid}, ${3:listener}, ${4:architecture})"
		]
	},
	"binjectsh": {
		"description": "Inject shellcode into a process",
		"prefix": "binjectsh",
		"body": [
			"binjectsh($0${1:beacon}, ${2:pid}, ${3:architecture}, ${4:file})"
		]
	},
	"binput": {
		"description": "Report a command was run to the Beacon console and logs. Scripts that execute commands for the user (e.g., events, popup menus) should use this function to assure operator attribution of automated actions in Beacon's logs",
		"prefix": "binput",
		"body": [
			"binput($0${1:beacon}, ${2:command})"
		]
	},
	"bipconfig": {
		"description": "Task a Beacon to list network interfaces",
		"prefix": "bipconfig",
		"body": [
			"bipconfig($0${1:beacon}, {",
			"\t$0",
			"});"
		]
	},
	"bjobkill": {
		"description": "Ask Beacon to kill a running post-exploitation job",
		"prefix": "bjobkill",
		"body": [
			"bjobkill($0${1:beacon}, ${2:job})"
		]
	},
	"bjobs": {
		"description": "Ask Beacon to list running post-exploitation jobs",
		"prefix": "bjobs",
		"body": [
			"bjobs($0${1:beacon})"
		]
	},
	"bjump": {
		"description": "Ask Beacon to spawn a session on a remote target",
		"prefix": "bjump",
		"body": [
			"bjump($0${1:beacon}, ${2:technique}, ${3:target}, ${4:listener})"
		]
	},
	"bkerberos_ccache_use": {
		"description": "Ask beacon to inject a UNIX kerberos ccache file into the user's kerberos tray",
		"prefix": "bkerberos_ccache_use",
		"body": [
			"bkerberos_ccache_use($0${1:beacon}, ${2:path})"
		]
	},
	"bkerberos_ticket_purge": {
		"description": "Ask beacon to purge tickets from the user's kerberos tray",
		"prefix": "bkerberos_ticket_purge",
		"body": [
			"bkerberos_ticket_purge($0${1:beacon})"
		]
	},
	"bkerberos_ticket_use": {
		"description": "Ask beacon to inject a mimikatz kirbi file into the user's kerberos tray",
		"prefix": "bkerberos_ticket_use",
		"body": [
			"bkerberos_ticket_use($0${1:beacon}, ${2:path})"
		]
	},
	"bkeylogger": {
		"description": "Injects a keystroke logger into a process.",
		"prefix": "bkeylogger",
		"body": [
			"bkeylogger($0${1:beacon}, ${2:pid}, ${3:architecture})"
		]
	},
	"bkill": {
		"description": "Ask Beacon to kill a process",
		"prefix": "bkill",
		"body": [
			"bkill($0${1:beacon}, ${2:pid})"
		]
	},
	"blink": {
		"description": "Ask Beacon to link to a host over a named pipe",
		"prefix": "blink",
		"body": [
			"blink($0${1:beacon}, ${2:target}, [${3:pipename}])"
		]
	},
	"blog": {
		"description": "Post a message to WordPress.com (just kidding). Publishes an output message to the Beacon transcript",
		"prefix": "blog",
		"body": [
			"blog($0${1:beacon}, ${2:message})"
		]
	},
	"blog2": {
		"description": "Publishes an output message to the Beacon transcript. This function has an alternate format from &blog",
		"prefix": "blog2",
		"body": [
			"blog2($0${1:beacon}, ${2:message})"
		]
	},
	"bloginuser": {
		"description": "Ask Beacon to create a token from the specified credentials. This is the make_token command",
		"prefix": "bloginuser",
		"body": [
			"bloginuser($0${1:beacon}, ${2:domain}, ${3:user}, ${4:password})"
		]
	},
	"blogonpasswords": {
		"description": "Ask Beacon to dump in-memory credentials with mimikatz",
		"prefix": "blogonpasswords",
		"body": [
			"blogonpasswords($0${1:beacon})"
		]
	},
	"bls": {
		"description": "Task a Beacon to list files",
		"prefix": "bls",
		"body": [
			"bls($0${1:beacon}, ${1:folder}, [${1:function}])"
		]
	},
	"bmimikatz": {
		"description": "Ask Beacon to run a mimikatz command",
		"prefix": "bmimikatz",
		"body": [
			"bmimikatz($0${1:beacon}, ${2:command})"
		]
	},
	"bmkdir": {
		"description": "Ask Beacon to make a directory",
		"prefix": "bmkdir",
		"body": [
			"bmkdir($0${1:beacon}, ${2:folder})"
		]
	},
	"bmode": {
		"description": "Change the data channel for a DNS Beacon",
		"prefix": "bmode",
		"body": [
			"bmode($0${1:beacon}, ${2:mode})"
		]
	},
	"bmv": {
		"description": "Ask Beacon to move a file or folder",
		"prefix": "bmv",
		"body": [
			"bmode($0${1:beacon}, ${2:source}, ${3:destination})"
		]
	},
	"bnet": {
		"description": "Run a command from Beacon's net module",
		"prefix": "bnet",
		"body": [
			"bnet($0${1:beacon}, ${2:command})"
		]
	},
	"bnote": {
		"description": "Assign a note to the specified Beacon",
		"prefix": "bnote",
		"body": [
			"bnote($0${1:beacon}, ${2:note})"
		]
	},
	"bpassthehash": {
		"description": "Ask Beacon to create a token that passes the specified hash. This is the pth command in Beacon. It uses mimikatz",
		"prefix": "bpassthehash",
		"body": [
			"bpassthehash($0${1:beacon}, ${2:domain}, ${3:user}, ${4:password})"
		]
	},
	"bpause": {
		"description": "Ask Beacon to pause its execution. This is a one-off sleep.",
		"prefix": "bpause",
		"body": [
			"bpause($0${1:beacon}, ${2:milliseconds})"
		]
	},
	"bportscan": {
		"description": "Ask Beacon to run its port scanner",
		"prefix": "bportscan",
		"body": [
			"bportscan($0${1:beacon}, ${2:target}, ${3:ports}, ${4:discovery}, ${5:maxsocket})"
		]
	},
	"bpowerpick": {
		"description": "Spawn a process, inject Unmanaged PowerShell, and run the specified command",
		"prefix": "bpowerpick",
		"body": [
			"bpowerpick($0${1:beacon}, ${2:cmdlet}, [${3:script}])"
		]
	},
	"bpowershell": {
		"description": "Ask Beacon to run a PowerShell cmdlet",
		"prefix": "bpowershell",
		"body": [
			"bpowershell($0${1:beacon}, ${2:cmdlet}, [${3:script}])"
		]
	},
	"bpowershell_import": {
		"description": "Import a PowerShell script into a Beacon",
		"prefix": "bpowershell_import",
		"body": [
			"bpowershell_import($0${1:beacon}, ${2:script})"
		]
	},
	"bpowershell_import_clear": {
		"description": "Clear the imported PowerShell script from a Beacon session",
		"prefix": "bpowershell_import_clear",
		"body": [
			"bpowershell_import_clear($0${1:beacon})"
		]
	},
	"bppid": {
		"description": "Set a parent process for Beacon's child processes",
		"prefix": "bppid",
		"body": [
			"bppid($0${1:beacon}, ${2:ppid})"
		]
	},
	"bps": {
		"description": "Task a Beacon to list processes",
		"prefix": "bps",
		"body": [
			"bps($0${1:beacon}, [${2:function}])"
		]
	},
	"bpsexec": {
		"description": "Ask Beacon to spawn a payload on a remote host. This function generates an Artifact Kit executable, copies it to the target, and creates a service to run it. Clean up is included too",
		"prefix": "bpsexec",
		"body": [
			"bpsexec($0${1:beacon}, ${2:target}, ${3:listener}, ${4:share}, ${5:architecture})"
		]
	},
	"bpsexec_command": {
		"description": "Ask Beacon to run a command on a remote host. This function creates a service on the remote host, starts it, and cleans it up",
		"prefix": "bpsexec_command",
		"body": [
			"bpsexec_command($0${1:beacon}, ${2:target}, ${3:name}, ${4:command})"
		]
	},
	"bpsinject": {
		"description": "Inject Unmanaged PowerShell into a specific process and run the specified cmdlet",
		"prefix": "bpsinject",
		"body": [
			"bpsinject($0${1:beacon}, ${2:pid}, ${3:architecture}, ${4:cmdlet})"
		]
	},
	"bpwd": {
		"description": "Ask Beacon to print its current working directory",
		"prefix": "bpwd",
		"body": [
			"bpwd($0${1:beacon})"
		]
	},
	"breg_query": {
		"description": "Ask Beacon to query a key within the registry",
		"prefix": "breg_query",
		"body": [
			"breg_query($0${1:beacon}, ${2:path}, ${3:architecture})"
		]
	},
	"breg_queryv": {
		"description": "Ask Beacon to query a value within a registry key",
		"prefix": "breg_queryv",
		"body": [
			"breg_queryv($0${1:beacon}, ${2:path}, ${3:name}, ${4:architecture})"
		]
	},
	"bremote_exec": {
		"description": "Ask Beacon to run a command on a remote target",
		"prefix": "bremote_exec",
		"body": [
			"bremote_exec($0${1:beacon}, ${2:method}, ${3:target}, ${4:command})"
		]
	},
	"brev2self": {
		"description": "Ask Beacon to drop its current token. This calls the RevertToSelf() Win32 API",
		"prefix": "brev2self",
		"body": [
			"brev2self($0${1:beacon})"
		]
	},
	"brm": {
		"description": "Ask Beacon to remove a file or folder",
		"prefix": "brm",
		"body": [
			"brm($0${1:beacon}, ${2:file})"
		]
	},
	"brportfwd": {
		"description": "Ask Beacon to setup a reverse port forward",
		"prefix": "brportfwd",
		"body": [
			"brportfwd($0${1:beacon}, ${2:port}, ${3:host}, ${4:port})"
		]
	},
	"brportfwd_stop": {
		"description": "Ask Beacon to stop a reverse port forward",
		"prefix": "brportfwd_stop",
		"body": [
			"brportfwd_stop($0${1:beacon}, ${2:port})"
		]
	},
	"brun": {
		"description": "Ask Beacon to run a command",
		"prefix": "brun",
		"body": [
			"brun($0${1:beacon}, ${2:command})"
		]
	},
	"brunas": {
		"description": "Ask Beacon to run a command as another user",
		"prefix": "brunas",
		"body": [
			"brunas($0${1:beacon}, ${2:domain}, ${3:user}, ${4:password}, ${5:command})"
		]
	},
	"brunasadmin": {
		"description": "Ask Beacon to run a command in a high-integrity context (bypasses UAC).",
		"prefix": "brunasadmin",
		"body": [
			"brunasadmin($0${1:beacon}, ${2:command})"
		]
	},
	"brunu": {
		"description": "Ask Beacon to run a process under another process.",
		"prefix": "brunu",
		"body": [
			"brunu($0${1:beacon}, ${2:pid}, ${3:command})"
		]
	},
	"bscreenshot": {
		"description": "Ask Beacon to take a screenshot",
		"prefix": "bscreenshot",
		"body": [
			"bscreenshot($0${1:beacon}, ${2:miliseconds})"
		]
	},
	"bsetenv": {
		"description": "Ask Beacon to set an environment variable",
		"prefix": "bsetenv",
		"body": [
			"bsetenv($0${1:beacon}, ${2:variable}, ${3:value})"
		]
	},
	"bshell": {
		"description": "Ask Beacon to run a command with cmd.exe",
		"prefix": "bshell",
		"body": [
			"bshell($0${1:beacon}, ${2:command})"
		]
	},
	"bshinject": {
		"description": "Inject shellcode (from a local file) into a specific process",
		"prefix": "bshinject",
		"body": [
			"bshinject($0${1:beacon}, ${2:pid}, ${3:architecture}, ${4:file})"
		]
	},
	"bshspawn": {
		"description": "Spawn shellcode (from a local file) into another process. This function benefits from Beacon's configuration to spawn post-exploitation jobs (e.g., spawnto, ppid, etc.)",
		"prefix": "bshspawn",
		"body": [
			"bshspawn($0${1:beacon}, ${2:architecture}, ${3:file})"
		]
	},
	"bsleep": {
		"description": "Ask Beacon to change its beaconing interval and jitter factor",
		"prefix": "bsleep",
		"body": [
			"bsleep($0${1:beacon}, ${2:seconds}, ${3:jitter})"
		]
	},
	"bsocks": {
		"description": "Start a SOCKS proxy server associated with a beacon",
		"prefix": "bsocks",
		"body": [
			"bsocks($0${1:beacon}, ${2:port})"
		]
	},
	"bsocks_stop": {
		"description": "Stop SOCKS proxy servers associated with the specified Beacon",
		"prefix": "bsocks_stop",
		"body": [
			"bsocks_stop($0${1:beacon})"
		]
	},
	"bspawn": {
		"description": "Ask Beacon to spawn a new session",
		"prefix": "bspawn",
		"body": [
			"bspawn($0${1:beacon}, ${2:listener}, ${3:architecture})"
		]
	},
	"bspawnas": {
		"description": "Ask Beacon to spawn a session as another user",
		"prefix": "bspawnas",
		"body": [
			"bspawnas($0${1:beacon}, ${2:domain}, ${3:user}, ${4:password}, ${5:listener})"
		]
	},
	"bspawnto": {
		"description": "Change the default program Beacon spawns to inject capabilities into",
		"prefix": "bspawnto",
		"body": [
			"bspawnto($0${1:beacon}, ${2:architecture}, ${3:program})"
		]
	},
	"bspawnu": {
		"description": "Ask Beacon to spawn a session under another process.",
		"prefix": "bspawnu",
		"body": [
			"bspawnto($0${1:beacon}, ${2:pid}, ${3:listener})"
		]
	},
	"bssh": {
		"description": "Ask Beacon to spawn an SSH session",
		"prefix": "bssh",
		"body": [
			"bssh($0${1:beacon}, ${2:ip}, ${3:port}, ${4:username}, ${5:password})"
		]
	},
	"bssh_key": {
		"description": "Ask Beacon to spawn an SSH session",
		"prefix": "bssh_key",
		"body": [
			"bssh_key($0${1:beacon}, ${2:ip}, ${3:port}, ${4:username}, ${5:key})"
		]
	},
	"bsteal_token": {
		"description": "Ask Beacon to steal a token from a process",
		"prefix": "bsteal_token",
		"body": [
			"bsteal_token($0${1:beacon}, ${2:pid})"
		]
	},
	"bsudo": {
		"description": "Ask Beacon to run a command via sudo (SSH sessions only)",
		"prefix": "bsudo",
		"body": [
			"bsudo($0${1:beacon}, ${2:password}, ${3:command})"
		]
	},
	"btask": {
		"description": "Report a task acknowledgement for a Beacon. This task acknowledgement will also contribute to the narrative in Cobalt Strike's Activity Report and Sessions Report",
		"prefix": "btask",
		"body": [
			"btask($0${1:beacon}, ${2:text}, ${3:MITRE_ID})"
		]
	},
	"btimestomp": {
		"description": "Ask Beacon to change the file modified/accessed/created times to match another file",
		"prefix": "btimestomp",
		"body": [
			"btimestomp($0${1:beacon}, ${2:file}, ${3:file})"
		]
	},
	"bunlink": {
		"description": "Ask Beacon to delink a Beacon its connected to over a TCP socket or named pipe",
		"prefix": "bunlink",
		"body": [
			"bunlink($0${1:beacon}, ${2:target}, [${3:pid}])"
		]
	},
	"bupload": {
		"description": "Ask a Beacon to upload a file",
		"prefix": "bupload",
		"body": [
			"bupload($0${1:beacon}, ${2:file})"
		]
	},
	"bupload_raw": {
		"description": "Ask a Beacon to upload a file",
		"prefix": "bupload_raw",
		"body": [
			"bupload_raw($0${1:beacon}, ${2:file}, ${3:content})"
		]
	},
	"call": {
		"description": "Issue a call to the team server",
		"prefix": "call",
		"body": [
			"call($0${1:command}, { ${2:function} } , ${3:...})"
		]
	},
	"closeClient": {
		"description": "Close the current Cobalt Strike team server connection",
		"prefix": "closeClient",
		"body": [
			"closeClient()"
		]
	},
	"colorPanel": {
		"description": "Generate a Java component to set accent colors within Cobalt Strike's data model",
		"prefix": "colorPanel",
		"body": [
			"colorPanel($0${1:prefix}, ${2:ids})"
		]
	},
	"credential_add": {
		"description": "Add a credential to the data model",
		"prefix": "credential_add",
		"body": [
			"credential_add($0${1:username}, ${2:password}, ${3:realm}, ${4:source}, ${5:host})"
		]
	},
	"credentials": {
		"description": "Returns a list of application credentials in Cobalt Strike's data model",
		"prefix": "credentials",
		"body": [
			"credentials()"
		]
	},
	"data_keys": {
		"description": "List the query-able keys from Cobalt Strike's data model",
		"prefix": "data_keys",
		"body": [
			"foreach $key (data_keys()) {",
			"\t$0",
			"}"
		]
	},
	"data_query": {
		"description": "Queries Cobalt Strike's data model",
		"prefix": "data_query",
		"body": [
			"data_query($0${1:key})"
		]
	},
	"dbutton_action": {
		"description": "Adds an action button to a &dialog. When this button is pressed, the dialog closes and its callback is called. You may add multiple buttons to a dialog. Cobalt Strike will line these buttons up in a row and center them at the bottom of the dialog",
		"prefix": "dbutton_action",
		"body": [
			"dbutton_action($0${1:dialog}, ${2:label})"
		]
	},
	"dbutton_help": {
		"description": "Adds a Help button to a &dialog. When this button is pressed, Cobalt Strike will open the user's browser to the specified URL",
		"prefix": "dbutton_help",
		"body": [
			"dbutton_help($0${1:dialog}, ${2:url})"
		]
	},
	"dialog": {
		"description": "Create a dialog. Use &dialog_show to show it.",
		"prefix": "dialog",
		"body": [
			"dialog($0${1:title}, ${2:defaults}, ${3:function})"
		]
	},
	"dialog_description": {
		"description": "Adds a description to a &dialog",
		"prefix": "dialog_description",
		"body": [
			"dialog_description($0${1:dialog}, ${2:description})"
		]
	},
	"dialog_show": {
		"description": "Shows a &dialog.",
		"prefix": "dialog_show",
		"body": [
			"dialog_show($0${1:dialog})"
		]
	},
	"dispatch_event": {
		"description": "Call a function in Java Swing's Event Dispatch Thread. Java's Swing Library is not thread safe. All changes to the user interface should happen from the Event Dispatch Thread",
		"prefix": "dispatch_event",
		"body": [
			"dispatch_event({",
			"\t$0",
			"});"
		]
	},
	"downloads": {
		"description": "Returns a list of downloads in Cobalt Strike's data model",
		"prefix": "downloads",
		"body": [
			"downloads()"
		]
	},
	"drow_beacon": {
		"description": "Adds a beacon selection row to a &dialog",
		"prefix": "drow_beacon",
		"body": [
			"drow_beacon($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_checkbox": {
		"description": "Adds a checkbox to a &dialog",
		"prefix": "drow_checkbox",
		"body": [
			"drow_checkbox($0${1:dialog}, ${2:name}, ${3:label}, ${4:text})"
		]
	},
	"drow_combobox": {
		"description": "Adds a combobox to a &dialog",
		"prefix": "drow_combobox",
		"body": [
			"drow_combobox($0${1:dialog}, ${2:name}, ${3:label}, ${4:array})"
		]
	},
	"drow_exploits": {
		"description": "Adds a privilege escalation exploit selection row to a &dialog",
		"prefix": "drow_exploits",
		"body": [
			"drow_exploits($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_file": {
		"description": "Adds a file chooser row to a &dialog",
		"prefix": "drow_file",
		"body": [
			"drow_file($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_interface": {
		"description": "Adds a VPN interface selection row to a &dialog",
		"prefix": "drow_interface",
		"body": [
			"drow_interface($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_krbtgt": {
		"description": "Adds a krbtgt selection row to a &dialog",
		"prefix": "drow_krbtgt",
		"body": [
			"drow_krbtgt($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_listener": {
		"description": "Adds a listener selection row to a &dialog. This row only shows listeners with stagers (e.g., windows/beacon_https/reverse_https).",
		"prefix": "drow_listener",
		"body": [
			"drow_listener($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_listener_stage": {
		"description": "Adds a listener selection row to a &dialog. This row shows all Beacon and Foreign listener payloads.",
		"prefix": "drow_listener_stage",
		"body": [
			"drow_listener_stage($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_mailserver": {
		"description": "Adds a mail server field to a &dialog.",
		"prefix": "drow_mailserver",
		"body": [
			"drow_mailserver($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_site": {
		"description": "Adds a site/URL field to a &dialog.",
		"prefix": "drow_site",
		"body": [
			"drow_site($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"drow_text": {
		"description": "Adds a text field row to a &dialog",
		"prefix": "drow_text",
		"body": [
			"drow_text($0${1:dialog}, ${2:name}, ${3:label}, [${4:width}])"
		]
	},
	"drow_text_big": {
		"description": "Adds a multi-line text field to a &dialog",
		"prefix": "drow_text_big",
		"body": [
			"drow_text_big($0${1:dialog}, ${2:name}, ${3:label})"
		]
	},
	"dstamp": {
		"description": "Format a time into a date/time value. This value includes seconds.",
		"prefix": "dstamp",
		"body": [
			"dstamp($0${1:milliseconds})"
		]
	},
	"elog": {
		"description": "Publish a notification to the event log",
		"prefix": "elog",
		"body": [
			"elog($0${1:text})"
		]
	},
	"encode": {
		"description": "Obfuscate a position-independent blob of code with an encoder",
		"prefix": "encode",
		"body": [
			"encode($0${1:shellcode}, ${2:encoder}, ${3:architecture})"
		]
	},
	"fireAlias": {
		"description": "Runs a user-defined alias",
		"prefix": "fireAlias",
		"body": [
			"fireAlias($0${1:beacon}, ${2:alias}, ${3:arguments})"
		]
	},
	"fireEvent": {
		"description": "Fire an event",
		"prefix": "fireEvent",
		"body": [
			"fireAlias($0${1:event}, ${2:arguments})"
		]
	},
	"format_size": {
		"description": "Formats a number into a size (e.g., 1024 => 1kb)",
		"prefix": "format_size",
		"body": [
			"format_size($0${1:size})"
		]
	},
	"getAggressorClient": {
		"description": "Returns the aggressor.AggressorClient Java object. This can reach anything internal within the current Cobalt Strike client context",
		"prefix": "getAggressorClient",
		"body": [
			"getAggressorClient()"
		]
	},
	"gunzip": {
		"description": "Decompress a string (GZIP).",
		"prefix": "gunzip",
		"body": [
			"gunzip($0${1:data})"
		]
	},
	"gzip": {
		"description": "GZIP a string",
		"prefix": "gzip",
		"body": [
			"gzip($0${1:data})"
		]
	},
	"highlight": {
		"description": "Insert an accent (color highlight) into Cobalt Strike's data model",
		"prefix": "highlight",
		"body": [
			"highlight($0${1:model}, ${2:array}, ${3:accent})"
		]
	},
	"host_delete": {
		"description": "Delete a host from the targets model",
		"prefix": "host_delete",
		"body": [
			"host_delete($0${1:host})"
		]
	},
	"host_info": {
		"description": "Get information about a target",
		"prefix": "host_info",
		"body": [
			"foreach $key => $value (host_info($0${1:host})) {",
			"\t$0",
			"}"
		]
	},
	"host_update": {
		"description": "Add or update a host in the targets model",
		"prefix": "host_update",
		"body": [
			"host_update($0${1:target}, ${2:dns}, ${3:os}, ${4:osversion}, ${5:note})"
		]
	},
	"hosts": {
		"description": "Returns a list of IP addresses from Cobalt Strike's target model",
		"prefix": "hosts",
		"body": [
			"hosts()"
		]
	},
	"insert_component": {
		"description": "Add a javax.swing.JComponent object to the menu tree",
		"prefix": "insert_component",
		"body": [
			"insert_component($0${1:component})"
		]
	},
	"insert_menu": {
		"description": "Bring menus associated with a popup hook into the current menu tree.",
		"prefix": "insert_menu",
		"body": [
			"insert_menu($0${1:hook}, ${2:arguments})"
		]
	},
	"iprange": {
		"description": "Generate an array of IPv4 addresses based on a string description",
		"prefix": "iprange",
		"body": [
			"iprange($0${1:range})"
		]
	},
	"keystrokes": {
		"description": "Returns a list of keystrokes from Cobalt Strike's data model",
		"prefix": "keystrokes",
		"body": [
			"keystrokes()"
		]
	},
	"licenseKey": {
		"description": "Get the license key for this instance of Cobalt Strike",
		"prefix": "licenseKey",
		"body": [
			"licenseKey()"
		]
	},
	"listener_create_ext": {
		"description": "Create a new listener",
		"prefix": "listener_create_ext",
		"body": [
			"listener_create_ext($0${1:name}, ${2:payload}, ${3:dictionary})"
		]
	},
	"listener_delete": {
		"description": "Stop and remove a listener",
		"prefix": "listener_delete",
		"body": [
			"listener_delete($0${1:name})"
		]
	},
	"listener_describe": {
		"description": "Describe a listener.",
		"prefix": "listener_describe",
		"body": [
			"listener_describe($0${1:name}, [${2:target}])"
		]
	},
	"listener_info": {
		"description": "Get information about a listener",
		"prefix": "listener_info",
		"body": [
			"listener_info($0${1:name}, [${2:key}])"
		]
	},
	"listener_pivot_create": {
		"description": "Create a new pivot listener",
		"prefix": "listener_pivot_create",
		"body": [
			"listener_pivot_create($0${1:beacon}, ${2:listener}, ${3:payload}, ${4:host}, ${5:port})"
		]
	},
	"listener_restart": {
		"description": "Restart a listener",
		"prefix": "listener_restart",
		"body": [
			"listener_restart($0${1:name})"
		]
	},
	"listeners": {
		"description": "Return a list of listener names (with stagers only!) across all team servers this client is connected to",
		"prefix": "listeners",
		"body": [
			"listeners()"
		]
	},
	"listeners_local": {
		"description": "Return a list of listener names. This function limits itself to the current team server only. External C2 listener names are omitted",
		"prefix": "listeners_local",
		"body": [
			"listeners_local()"
		]
	},
	"listeners_stageless": {
		"description": "Return a list of listener names across all team servers this client is connected to. External C2 listeners are filtered (as they're not actionable via staging or exporting as a Reflective DLL).",
		"prefix": "listeners_stageless",
		"body": [
			"listeners_stageless()"
		]
	},
	"localip": {
		"description": "Get the IP address associated with the team server.",
		"prefix": "localip",
		"body": [
			"localip()"
		]
	},
	"menubar": {
		"description": "Add a top-level item to the menubar",
		"prefix": "menubar",
		"body": [
			"menubar($0${1:description}, ${2:hook})"
		]
	},
	"mynick": {
		"description": "Get the nickname associated with the current Cobalt Strike client",
		"prefix": "mynick",
		"body": [
			"mynick()"
		]
	},
	"nextTab": {
		"description": "Activate the tab that is to the right of the current tab",
		"prefix": "nextTab",
		"body": [
			"nextTab()"
		]
	},
	"on": {
		"description": "Register an event handler. This is an alternate to the on keyword",
		"prefix": "on",
		"body": [
			"on($0${1:event}, ${2:function})"
		]
	},
	"openAboutDialog": {
		"description": "Open the \"About Cobalt Strike\" dialog",
		"prefix": "openAboutDialog",
		"body": [
			"openAboutDialog()"
		]
	},
	"openApplicationManager": {
		"description": "Open the application manager (system profiler results) tab",
		"prefix": "openApplicationManager",
		"body": [
			"openApplicationManager()"
		]
	},
	"openBeaconBrowser": {
		"description": "Open the beacon browser tab",
		"prefix": "openBeaconBrowser",
		"body": [
			"openBeaconBrowser()"
		]
	},
	"openBeaconConsole": {
		"description": "Open the console to interact with a Beacon",
		"prefix": "openBeaconConsole",
		"body": [
			"openBeaconConsole($0${1:beacon})"
		]
	},
	"openBrowserPivotSetup": {
		"description": "open the browser pivot setup dialog",
		"prefix": "openBrowserPivotSetup",
		"body": [
			"openBrowserPivotSetup($0${1:beacon})"
		]
	},
	"openBypassUACDialog": {
		"description": "Open the dialog for the Bypass UAC feature.",
		"prefix": "openBypassUACDialog",
		"body": [
			"openBypassUACDialog($0${1:beacon})"
		]
	},
	"openCloneSiteDialog": {
		"description": "Open the dialog for the website clone tool",
		"prefix": "openCloneSiteDialog",
		"body": [
			"openCloneSiteDialog()"
		]
	},
	"openConnectDialog": {
		"description": "Open the connect dialog",
		"prefix": "openConnectDialog",
		"body": [
			"openConnectDialog()"
		]
	},
	"openCovertVPNSetup": {
		"description": "open the Covert VPN setup dialog",
		"prefix": "openCovertVPNSetup",
		"body": [
			"openCovertVPNSetup($0${1:beacon})"
		]
	},
	"openCredentialManager": {
		"description": "Open the credential manager tab",
		"prefix": "openCredentialManager",
		"body": [
			"openCredentialManager()"
		]
	},
	"openDownloadBrowser": {
		"description": "Open the download browser tab",
		"prefix": "openDownloadBrowser",
		"body": [
			"openDownloadBrowser()"
		]
	},
	"openElevateDialog": {
		"description": "Open the dialog to launch a privilege escalation exploit",
		"prefix": "openElevateDialog",
		"body": [
			"openElevateDialog($0${1:beacon})"
		]
	},
	"openEventLog": {
		"description": "Open the event log",
		"prefix": "openEventLog",
		"body": [
			"openEventLog()"
		]
	},
	"openFileBrowser": {
		"description": "Open the file browser for a Beacon",
		"prefix": "openFileBrowser",
		"body": [
			"openFileBrowser($0${1:beacon})"
		]
	},
	"openGoldenTicketDialog": {
		"description": "open a dialog to help generate a golden ticket",
		"prefix": "openGoldenTicketDialog",
		"body": [
			"openGoldenTicketDialog($0${1:beacon})"
		]
	},
	"openHTMLApplicationDialog": {
		"description": "Open the HTML Application Dialog.",
		"prefix": "openHTMLApplicationDialog",
		"body": [
			"openHTMLApplicationDialog()"
		]
	},
	"openHostFileDialog": {
		"description": "Open the host file dialog",
		"prefix": "openHostFileDialog",
		"body": [
			"openHostFileDialog()"
		]
	},
	"openInterfaceManager": {
		"description": "Open the tab to manage Covert VPN interfaces",
		"prefix": "openInterfaceManager",
		"body": [
			"openInterfaceManager()"
		]
	},
	"openJavaSignedAppletDialog": {
		"description": "Open the Java Signed Applet dialog",
		"prefix": "openJavaSignedAppletDialog",
		"body": [
			"openJavaSignedAppletDialog()"
		]
	},
	"openJavaSmartAppletDialog": {
		"description": "Open the Java Smart Applet dialog",
		"prefix": "openJavaSmartAppletDialog",
		"body": [
			"openJavaSmartAppletDialog()"
		]
	},
	"openJumpDialog": {
		"description": "Open Cobalt Strike's lateral movement dialog",
		"prefix": "openJumpDialog",
		"body": [
			"openJumpDialog($0${1:method}, ${2:array})"
		]
	},
	"openKeystrokeBrowser": {
		"description": "Open the keystroke browser tab",
		"prefix": "openKeystrokeBrowser",
		"body": [
			"openKeystrokeBrowser()"
		]
	},
	"openListenerManager": {
		"description": "Open the listener manager",
		"prefix": "openListenerManager",
		"body": [
			"openListenerManager()"
		]
	},
	"openMakeTokenDialog": {
		"description": "open a dialog to help generate an access token",
		"prefix": "openMakeTokenDialog",
		"body": [
			"openMakeTokenDialog($0${1:method})"
		]
	},
	"openOfficeMacro": {
		"description": "Open the office macro export dialog",
		"prefix": "openOfficeMacro",
		"body": [
			"openOfficeMacro()"
		]
	},
	"openOneLinerDialog": {
		"description": "Open the dialog to generate a PowerShell one-liner for this specific Beacon session",
		"prefix": "openOneLinerDialog",
		"body": [
			"openOneLinerDialog($0${1:beacon})"
		]
	},
	"openOrActivate": {
		"description": "If a Beacon console exists, make it active. If a Beacon console does not exist, open it.",
		"prefix": "openOrActivate",
		"body": [
			"openOrActivate($0${1:beacon})"
		]
	},
	"openPayloadGeneratorDialog": {
		"description": "Open the Payload Generator dialog.",
		"prefix": "openPayloadGeneratorDialog",
		"body": [
			"openPayloadGeneratorDialog()"
		]
	},
	"openPayloadHelper": {
		"description": "",
		"prefix": "openPayloadHelper",
		"body": [
			"openPayloadGeneratorDialog(lambda({",
			"\t$0",
			"}, ${1:dictonary}));"
		]
	},
	"openPivotListenerSetup": {
		"description": "open the pivot listener setup dialog",
		"prefix": "openPivotListenerSetup",
		"body": [
			"openPivotListenerSetup($0${1:beacon})"
		]
	},
	"openPortScanner": {
		"description": "Open the port scanner dialog",
		"prefix": "openPortScanner",
		"body": [
			"openPortScanner($0${1:array})"
		]
	},
	"openPortScannerLocal": {
		"description": "Open the port scanner dialog with options to target a Beacon's local network",
		"prefix": "openPortScannerLocal",
		"body": [
			"openPortScannerLocal($0${1:beacon})"
		]
	},
	"openPowerShellWebDialog": {
		"description": "Open the dialog to setup the PowerShell Web Delivery Attack",
		"prefix": "openPowerShellWebDialog",
		"body": [
			"openPowerShellWebDialog()"
		]
	},
	"openPreferencesDialog": {
		"description": "Open the preferences dialog",
		"prefix": "openPreferencesDialog",
		"body": [
			"openPreferencesDialog()"
		]
	},
	"openProcessBrowser": {
		"description": "Open a process browser for one or more Beacons",
		"prefix": "openProcessBrowser",
		"body": [
			"openProcessBrowser($0${1:beacon})"
		]
	},
	"openSOCKSBrowser": {
		"description": "Open the tab to list SOCKS proxy servers",
		"prefix": "openSOCKSBrowser",
		"body": [
			"openSOCKSBrowser()"
		]
	},
	"openSOCKSSetup": {
		"description": "open the SOCKS proxy server setup dialog",
		"prefix": "openSOCKSSetup",
		"body": [
			"openSOCKSSetup($0${1:beacon})"
		]
	},
	"openScreenshotBrowser": {
		"description": "Open the screenshot browser tab",
		"prefix": "openScreenshotBrowser",
		"body": [
			"openScreenshotBrowser()"
		]
	},
	"openScriptConsole": {
		"description": "Open the Aggressor Script console",
		"prefix": "openScriptConsole",
		"body": [
			"openScriptConsole()"
		]
	},
	"openScriptManager": {
		"description": "Open the tab for the script manager.",
		"prefix": "openScriptManager",
		"body": [
			"openScriptManager()"
		]
	},
	"openScriptedWebDialog": {
		"description": "Open the dialog to setup a Scripted Web Delivery Attack",
		"prefix": "openScriptedWebDialog",
		"body": [
			"openScriptedWebDialog()"
		]
	},
	"openServiceBrowser": {
		"description": "Open service browser dialog",
		"prefix": "openServiceBrowser",
		"body": [
			"openServiceBrowser($0${1:array})"
		]
	},
	"openSiteManager": {
		"description": "Open the site manager",
		"prefix": "openSiteManager",
		"body": [
			"openSiteManager()"
		]
	},
	"openSpawnAsDialog": {
		"description": "Open dialog to spawn a payload as another user",
		"prefix": "openSpawnAsDialog",
		"body": [
			"openSpawnAsDialog($0${1:beacon})"
		]
	},
	"openSpearPhishDialog": {
		"description": "Open the dialog for the spear phishing tool.",
		"prefix": "openSpearPhishDialog",
		"body": [
			"openSpearPhishDialog()"
		]
	},
	"openSystemInformationDialog": {
		"description": "Open the system information dialog.",
		"prefix": "openSystemInformationDialog",
		"body": [
			"openSystemInformationDialog()"
		]
	},
	"openSystemProfilerDialog": {
		"description": "Open the dialog to setup the system profiler.",
		"prefix": "openSystemProfilerDialog",
		"body": [
			"openSystemProfilerDialog()"
		]
	},
	"openTargetBrowser": {
		"description": "Open the targets browser",
		"prefix": "openTargetBrowser",
		"body": [
			"openTargetBrowser()"
		]
	},
	"openWebLog": {
		"description": "Open the web log tab.",
		"prefix": "openWebLog",
		"body": [
			"openWebLog()"
		]
	},
	"openWindowsExecutableDialog": {
		"description": "Open the dialog to generate a Windows executable",
		"prefix": "openWindowsExecutableDialog",
		"body": [
			"openWindowsExecutableDialog()"
		]
	},
	"openWindowsExecutableStage": {
		"description": "Open the dialog to generate a stageless Windows executable",
		"prefix": "openWindowsExecutableStage",
		"body": [
			"openWindowsExecutableStage()"
		]
	},
	"payload": {
		"description": "Exports a raw payload for a specific Cobalt Strike listener",
		"prefix": "payload",
		"body": [
			"payload($0${1:listener}, ${2:architecture})"
		]
	},
	"pgraph": {
		"description": "Generate the pivot graph GUI component",
		"prefix": "pgraph",
		"body": [
			"pgraph()"
		]
	},
	"pivots": {
		"description": "Returns a list of SOCKS pivots from Cobalt Strike's data model",
		"prefix": "pivots",
		"body": [
			"pivots()"
		]
	},
	"popup_clear": {
		"description": "Remove all popup menus associated with the current menu. This is a way to override Cobalt Strike's default popup menu definitions",
		"prefix": "popup_clear",
		"body": [
			"popup_clear($0${1:name})"
		]
	},
	"powershell_command": {
		"description": "Returns a one-liner to run a PowerShell expression (e.g., powershell.exe -nop -w hidden -encodedcommand MgAgACsAIAAyAA==)",
		"prefix": "powershell_command",
		"body": [
			"powershell_command($0${1:command}, ${2:boolean})"
		]
	},
	"powershell_compress": {
		"description": "Compresses a PowerShell script and wraps it in a script to decompress and execute it.",
		"prefix": "powershell_compress",
		"body": [
			"powershell_compress($0${1:command})"
		]
	},
	"pref_get": {
		"description": "Grabs a string value from Cobalt Strike's preferences",
		"prefix": "pref_get",
		"body": [
			"pref_get($0${1:name}, ${2:value})"
		]
	},
	"pref_get_list": {
		"description": "Grabs a list value from Cobalt Strike's preferences.",
		"prefix": "pref_get_list",
		"body": [
			"pref_get_list($0${1:name})"
		]
	},
	"pref_set": {
		"description": "Set a value in Cobalt Strike's preferences",
		"prefix": "pref_set",
		"body": [
			"pref_set($0${1:name}, ${2:value})"
		]
	},
	"pref_set_list": {
		"description": "Stores a list value into Cobalt Strike's preferences.",
		"prefix": "pref_set_list",
		"body": [
			"pref_set_list($0${1:name}, ${2:array})"
		]
	},
	"previousTab": {
		"description": "Activate the tab that is to the left of the current tab.",
		"prefix": "previousTab",
		"body": [
			"previousTab()"
		]
	},
	"privmsg": {
		"description": "Post a private message to a user in the event log",
		"prefix": "privmsg",
		"body": [
			"privmsg($0${1:user}, ${2:message})"
		]
	},
	"prompt_confirm": {
		"description": "Show a dialog with Yes/No buttons. If the user presses yes, call the specified function.",
		"prefix": "prompt_confirm",
		"body": [
			"prompt_confirm($0${1:text}, ${2:title}, {",
			"\t",
			"});"
		]
	},
	"prompt_directory_open": {
		"description": "Show a directory open dialog.",
		"prefix": "prompt_directory_open",
		"body": [
			"prompt_directory_open($0${1:text}, $null, ${2:boolean}, {",
			"\t",
			"});"
		]
	},
	"prompt_file_open": {
		"description": "Show a file open dialog.",
		"prefix": "prompt_file_open",
		"body": [
			"prompt_file_open($0${1:text}, $null, ${2:boolean}, {",
			"\t",
			"});"
		]
	},
	"prompt_file_save": {
		"description": "Show a file save dialog.",
		"prefix": "prompt_file_save",
		"body": [
			"prompt_file_open($null, {",
			"\t$0",
			"});"
		]
	},
	"prompt_text": {
		"description": "Show a dialog that asks the user for text.",
		"prefix": "prompt_text",
		"body": [
			"prompt_text($0${1:text}, $null {",
			"\t",
			"});"
		]
	},
	"range": {
		"description": "Generate an array of numbers based on a string description of ranges.",
		"prefix": "range",
		"body": [
			"range($0${1:range})"
		]
	},
	"removeTab": {
		"description": "Close the active tab",
		"prefix": "removeTab",
		"body": [
			"removeTab()"
		]
	},
	"resetData": {
		"description": "Reset Cobalt Strike's data model",
		"prefix": "resetData",
		"body": [
			"resetData()"
		]
	},
	"say": {
		"description": "Post a public chat message to the event log.",
		"prefix": "say",
		"body": [
			"say($0${1:message})"
		]
	},
	"sbrowser": {
		"description": "Generate the session browser GUI component. Shows Beacon AND SSH sessions.",
		"prefix": "sbrowser",
		"body": [
			"sbrowser()"
		]
	},
	"screenshots": {
		"description": "Returns a list of screenshots from Cobalt Strike's data model",
		"prefix": "screenshots",
		"body": [
			"screenshots()"
		]
	},
	"script_resource": {
		"description": "Returns the full path to a resource that is stored relative to this script file.",
		"prefix": "script_resource",
		"body": [
			"script_resource($0${1:file})"
		]
	},
	"separator": {
		"description": "Insert a separator into the current menu tree.",
		"prefix": "separator",
		"body": [
			"separator()"
		]
	},
	"services": {
		"description": "Returns a list of services in Cobalt Strike's data model.",
		"prefix": "services",
		"body": [
			"services()"
		]
	},
	"showVisualization": {
		"description": "Switch Cobalt Strike visualization to a registered visualization.",
		"prefix": "showVisualization",
		"body": [
			"showVisualization($0${1:name})"
		]
	},
	"show_error": {
		"description": "Shows an error message to the user in a dialog box. Use this function to relay error information.",
		"prefix": "show_error",
		"body": [
			"show_error($0${1:message})"
		]
	},
	"show_message": {
		"description": "Shows a message to the user in a dialog box. Use this function to relay information.",
		"prefix": "show_message",
		"body": [
			"show_message($0${1:message})"
		]
	},
	"site_host": {
		"description": "Host content on Cobalt Strike's web server",
		"prefix": "site_host",
		"body": [
			"site_host($0${1:host}, ${2:port}, ${3:uri}, ${4:content}, ${5:mimetype}, ${6:description}, ${7:boolean})"
		]
	},
	"site_kill": {
		"description": "Remove a site from Cobalt Strike's web server",
		"prefix": "site_kill",
		"body": [
			"site_kill($0${1:port}, ${2:port})"
		]
	},
	"sites": {
		"description": "Returns a list of sites tied to Cobalt Strike's web server.",
		"prefix": "sites",
		"body": [
			"sites()"
		]
	},
	"ssh_command_describe": {
		"description": "Describe an SSH command",
		"prefix": "ssh_command_describe",
		"body": [
			"ssh_command_describe($0${1:command})"
		]
	},
	"ssh_command_detail": {
		"description": "Get the help information for an SSH command.",
		"prefix": "ssh_command_detail",
		"body": [
			"ssh_command_detail($0${1:command})"
		]
	},
	"ssh_command_register": {
		"description": "Register help information for an SSH console command.",
		"prefix": "ssh_command_register",
		"body": [
			"ssh_command_register($0${1:command}, ${2:description}, ${3:function})"
		]
	},
	"ssh_commands": {
		"description": "Get a list of SSH commands.",
		"prefix": "ssh_commands",
		"body": [
			"ssh_commands()"
		]
	},
	"stager": {
		"description": "Returns the stager for a specific Cobalt Strike listener",
		"prefix": "stager",
		"body": [
			"stager($0${1:listener}, ${2:architecture})"
		]
	},
	"stager_bind_pipe": {
		"description": "Returns a bind_pipe stager for a specific Cobalt Strike listener. This stager is suitable for use in lateral movement actions that benefit from a small named pipe stager. Stage with &beacon_stage_pipe.",
		"prefix": "stager_bind_pipe",
		"body": [
			"stager_bind_pipe($0${1:listener})"
		]
	},
	"stager_bind_tcp": {
		"description": "Returns a bind_tcp stager for a specific Cobalt Strike listener. This stager is suitable for use in localhost-only actions that require a small stager. Stage with &beacon_stage_tcp.",
		"prefix": "stager_bind_tcp",
		"body": [
			"stager_bind_tcp($0${1:listener}, ${2:architecture}, ${3:port})"
		]
	},
	"str_chunk": {
		"description": "Chunk a string into multiple parts",
		"prefix": "str_chunk",
		"body": [
			"str_chunk($0${1:string}, ${2:size})"
		]
	},
	"str_decode": {
		"description": "Convert a string of bytes to text with the specified encoding.",
		"prefix": "str_decode",
		"body": [
			"str_decode($0${1:string}, ${2:encoding})"
		]
	},
	"str_encode": {
		"description": "Convert text to byte string with the specified character encoding.",
		"prefix": "str_encode",
		"body": [
			"str_encode($0${1:string}, ${2:encoding})"
		]
	},
	"str_xor": {
		"description": "Walk a string and XOR it with the provided key.",
		"prefix": "str_xor",
		"body": [
			"str_xor($0${1:string}, ${2:key})"
		]
	},
	"sync_download": {
		"description": "Sync a downloaded file (View -> Downloads) to a local path.",
		"prefix": "sync_download",
		"body": [
			"sync_download($0${1:source}, ${2:destination}, [${3:function}])"
		]
	},
	"targets": {
		"description": "Returns a list of host information in Cobalt Strike's data model.",
		"prefix": "targets",
		"body": [
			"targets()"
		]
	},
	"tbrowser": {
		"description": "Generate the target browser GUI component.",
		"prefix": "tbrowser",
		"body": [
			"tbrowser()"
		]
	},
	"tokenToEmail": {
		"description": "Covert a phishing token to an email address.",
		"prefix": "tokenToEmail",
		"body": [
			"tokenToEmail($0${1:token})"
		]
	},
	"transform": {
		"description": "Transform shellcode into another format.",
		"prefix": "transform",
		"body": [
			"transform($0${1:shellcode}, ${2:type})"
		]
	},
	"transform_vbs": {
		"description": "Transform shellcode into a VBS expression that results in a string",
		"prefix": "transform_vbs",
		"body": [
			"transform_vbs($0${1:shellcode}, ${2:maxlength})"
		]
	},
	"tstamp": {
		"description": "Format a time into a date/time value. This value does not include seconds.",
		"prefix": "tstamp",
		"body": [
			"tstamp($0${1:milliseconds})"
		]
	},
	"url_open": {
		"description": "Open a URL in the default browser.",
		"prefix": "url_open",
		"body": [
			"url_open($0${1:url})"
		]
	},
	"users": {
		"description": "Returns a list of users connected to this team server.",
		"prefix": "users",
		"body": [
			"users()"
		]
	},
	"vpn_interface_info": {
		"description": "Get information about a VPN interface.",
		"prefix": "vpn_interface_info",
		"body": [
			"vpn_interface_info($0${1:interface}, [${2:key}])"
		]
	},
	"vpn_interfaces": {
		"description": "Return a list of VPN interface names",
		"prefix": "vpn_interfaces",
		"body": [
			"vpn_interfaces()"
		]
	},
	"vpn_tap_create": {
		"description": "",
		"prefix": "vpn_tap_create",
		"body": [
			"vpn_tap_create($0${1:interface}, ${2:mac}, $null, ${3:port}, ${4:type})"
		]
	},
	"vpn_tap_delete": {
		"description": "Destroy a Covert VPN interface",
		"prefix": "vpn_tap_delete",
		"body": [
			"vpn_tap_delete($0${1:interface})"
		]
	},
	"beacon_checkin": {
		"description": "Fired when a Beacon checkin acknowledgement is posted to a Beacon's console",
		"prefix": "beacon_checkin",
		"body": [
			"on beacon_checkin {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_error": {
		"description": "Fired when an error is posted to a Beacon's console.",
		"prefix": "beacon_error",
		"body": [
			"on beacon_error {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_indicator": {
		"description": "Fired when an indicator of compromise notice is posted to a Beacon's console.",
		"prefix": "beacon_indicator",
		"body": [
			"on beacon_indicator {",
			"\t\\$beacon = \\$1;",
			"\t\\$user = \\$2;",
			"\t\\$message = \\$3;",
			"\t\\$when = \\$4;",
			"\t$0",
			"}"
		]
	},
	"beacon_initial": {
		"description": "Fired when a Beacon calls home for the first time.",
		"prefix": "beacon_initial",
		"body": [
			"on beacon_indicator {",
			"\t\\$beacon = \\$1;",
			"\t$0",
			"}"
		]
	},
	"beacon_initial_empty": {
		"description": "Fired when a DNS Beacon calls home for the first time. At this point, no metadata has been exchanged.",
		"prefix": "beacon_initial_empty",
		"body": [
			"on beacon_initial_empty {",
			"\t\\$beacon = \\$1;",
			"\t$0",
			"}"
		]
	},
	"beacon_input": {
		"description": "Fired when an input message is posted to a Beacon's console.",
		"prefix": "beacon_input",
		"body": [
			"on beacon_input {",
			"\t\\$beacon = \\$1;",
			"\t\\$user = \\$2;",
			"\t\\$message = \\$3;",
			"\t\\$when = \\$4;",
			"\t$0",
			"}"
		]
	},
	"beacon_mode": {
		"description": "Fired when a mode change acknowledgement is posted to a Beacon's console.",
		"prefix": "beacon_mode",
		"body": [
			"on beacon_mode {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_output": {
		"description": "Fired when output is posted to a Beacon's console.",
		"prefix": "beacon_output",
		"body": [
			"on beacon_output {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_output_alt": {
		"description": "Fired when (alternate) output is posted to a Beacon's console. What makes for alternate output? It's just different presentation from normal output.",
		"prefix": "beacon_output_alt",
		"body": [
			"on beacon_output_alt {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_output_jobs": {
		"description": "Fired when jobs output is sent to a Beacon's console.",
		"prefix": "beacon_output_jobs",
		"body": [
			"on beacon_output_jobs {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_output_ls": {
		"description": "Fired when ls output is sent to a Beacon's console.",
		"prefix": "beacon_output_ls",
		"body": [
			"on beacon_output_ls {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_output_ps": {
		"description": "Fired when ps output is sent to a Beacon's console.",
		"prefix": "beacon_output_ps",
		"body": [
			"on beacon_output_ps {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacon_tasked": {
		"description": "Fired when a task acknowledgement is posted to a Beacon's console.",
		"prefix": "beacon_tasked",
		"body": [
			"on beacon_tasked {",
			"\t\\$beacon = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"beacons": {
		"description": "Fired when the team server sends over fresh information on all of our Beacons. This occurs about once each second.",
		"prefix": "beacons",
		"body": [
			"on beacons {",
			"\t\\$data = \\$1;",
			"\t$0",
			"}"
		]
	},
	"disconnect": {
		"description": "Fired when this Cobalt Strike becomes disconnected from the team server.",
		"prefix": "disconnect",
		"body": [
			"on disconnect {",
			"\t$0",
			"}"
		]
	},
	"event_action": {
		"description": "Fired when a user performs an action in the event log. This is similar to an action on IRC (the /me command)",
		"prefix": "event_action",
		"body": [
			"on event_action {",
			"\t\\$user = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"event_beacon_initial": {
		"description": "Fired when an initial beacon message is posted to the event log.",
		"prefix": "event_beacon_initial",
		"body": [
			"on event_beacon_initial {",
			"\t\\$message = \\$1;",
			"\t\\$when = \\$2;",
			"\t$0",
			"}"
		]
	},
	"event_join": {
		"description": "Fired when a user connects to the team server",
		"prefix": "event_join",
		"body": [
			"on event_join {",
			"\t\\$user = \\$1;",
			"\t\\$when = \\$2;",
			"\t$0",
			"}"
		]
	},
	"event_newsite": {
		"description": "Fired when a new site message is posted to the event log.",
		"prefix": "event_newsite",
		"body": [
			"on event_newsite {",
			"\t\\$user = \\$1;",
			"\t\\$content = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"event_notify": {
		"description": "Fired when a message from the team server is posted to the event log.",
		"prefix": "event_notify",
		"body": [
			"on event_notify {",
			"\t\\$content = \\$1;",
			"\t\\$when = \\$2;",
			"\t$0",
			"}"
		]
	},
	"event_nouser": {
		"description": "Fired when the current Cobalt Strike client tries to interact with a user who is not connected to the team server.",
		"prefix": "event_nouser",
		"body": [
			"on event_nouser {",
			"\t\\$user = \\$1;",
			"\t\\$when = \\$2;",
			"\t$0",
			"}"
		]
	},
	"event_private": {
		"description": "Fired when a private message is posted to the event log.",
		"prefix": "event_private",
		"body": [
			"on event_nouser {",
			"\t\\$from = \\$1;",
			"\t\\$to = \\$2;",
			"\t\\$content = \\$3;",
			"\t\\$when = \\$4;",
			"\t$0",
			"}"
		]
	},
	"event_public": {
		"description": "Fired when a public message is posted to the event log.",
		"prefix": "event_public",
		"body": [
			"on event_public {",
			"\t\\$user = \\$1;",
			"\t\\$content = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"event_quit": {
		"description": "Fired when someone disconnects from the team server.",
		"prefix": "event_quit",
		"body": [
			"on event_quit {",
			"\t\\$user = \\$1;",
			"\t\\$when = \\$2;",
			"\t$0",
			"}"
		]
	},
	"heartbeat_10m": {
		"description": "Fired every ten minutes",
		"prefix": "heartbeat_10m",
		"body": [
			"on heartbeat_10m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_10s": {
		"description": "Fired every ten seconds",
		"prefix": "heartbeat_10s",
		"body": [
			"on heartbeat_10s {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_15m": {
		"description": "Fired every fifteen minutes",
		"prefix": "heartbeat_15m",
		"body": [
			"on heartbeat_15m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_15s": {
		"description": "Fired every fifteen seconds",
		"prefix": "heartbeat_15s",
		"body": [
			"on heartbeat_15s {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_1m": {
		"description": "Fired every minute",
		"prefix": "heartbeat_1m",
		"body": [
			"on heartbeat_1m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_1s": {
		"description": "Fired every second",
		"prefix": "heartbeat_1s",
		"body": [
			"on heartbeat_1s {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_20m": {
		"description": "Fired every twenty minutes",
		"prefix": "heartbeat_20m",
		"body": [
			"on heartbeat_20m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_30m": {
		"description": "Fired every thirty minutes",
		"prefix": "heartbeat_30m",
		"body": [
			"on heartbeat_30m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_30s": {
		"description": "Fired every thirty seconds",
		"prefix": "heartbeat_30s",
		"body": [
			"on heartbeat_30s {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_5m": {
		"description": "Fired every five minutes",
		"prefix": "heartbeat_5m",
		"body": [
			"on heartbeat_5m {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_5s": {
		"description": "Fired every five seconds",
		"prefix": "heartbeat_5s",
		"body": [
			"on heartbeat_5s {",
			"\t$0",
			"}"
		]
	},
	"heartbeat_60m": {
		"description": "Fired every sixty minutes",
		"prefix": "heartbeat_60m",
		"body": [
			"on heartbeat_60m {",
			"\t$0",
			"}"
		]
	},
	"keylogger_hit": {
		"description": "Fired when there are new results reported to the web server via the cloned site keystroke logger.",
		"prefix": "keylogger_hit",
		"body": [
			"on keylogger_hit {",
			"\t\\$address = \\$1;",
			"\t\\$reserved = \\$2;",
			"\t\\@keystrokes = \\$3;",
			"\t\\$token = \\$4;",
			"\t$0",
			"}"
		]
	},
	"profiler_hit": {
		"description": "Fired when there are new results reported to the System Profiler.",
		"prefix": "profiler_hit",
		"body": [
			"on profiler_hit {",
			"\t\\$address = \\$1;",
			"\t\\$internalAddress = \\$2;",
			"\t\\$userAgent = \\$3;",
			"\t\\%applications = \\$4;",
			"\t\\$token = \\$5;",
			"\t$0",
			"}"
		]
	},
	"ready": {
		"description": "Fired when this Cobalt Strike client is connected to the team server and ready to act.",
		"prefix": "ready",
		"body": [
			"on ready {",
			"\t$0",
			"}"
		]
	},
	"sendmail_done": {
		"description": "Fired when a phishing campaign completes",
		"prefix": "sendmail_done",
		"body": [
			"on sendmail_done {",
			"\t\\$campaign = \\$1;",
			"\t$0",
			"}"
		]
	},
	"sendmail_post": {
		"description": "Fired after a phish is sent to an email address.",
		"prefix": "sendmail_post",
		"body": [
			"on sendmail_post {",
			"\t\\$campaign = \\$1;",
			"\t\\$email = \\$2;",
			"\t\\$status = \\$3;",
			"\t\\$message = \\$4;",
			"\t$0",
			"}"
		]
	},
	"sendmail_pre": {
		"description": "Fired before a phish is sent to an email address.",
		"prefix": "sendmail_pre",
		"body": [
			"on sendmail_pre {",
			"\t\\$campaign = \\$1;",
			"\t\\$email = \\$2;",
			"\t$0",
			"}"
		]
	},
	"sendmail_start": {
		"description": "Fired when a new phishing campaign kicks off.",
		"prefix": "sendmail_start",
		"body": [
			"on sendmail_start {",
			"\t\\$campaign = \\$1;",
			"\t\\$targets = \\$2;",
			"\t\\$attachment = \\$3;",
			"\t\\$address = \\$4;",
			"\t\\$mailServer = \\$5;",
			"\t\\$subject = \\$6;",
			"\t\\$template = \\$7;",
			"\t\\$url = \\$8;",
			"\t$0",
			"}"
		]
	},
	"ssh_checkin": {
		"description": "Fired when an SSH client checkin acknowledgement is posted to an SSH console.",
		"prefix": "ssh_checkin",
		"body": [
			"on ssh_checkin {",
			"\t\\$session = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"ssh_error": {
		"description": "Fired when an error is posted to an SSH console.",
		"prefix": "ssh_error",
		"body": [
			"on ssh_error {",
			"\t\\$session = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"ssh_indicator": {
		"description": "",
		"prefix": "ssh_indicator",
		"body": [
			"on ssh_indicator {",
			"\t\\$session = \\$1;",
			"\t\\$user = \\$2;",
			"\t\\$message = \\$3;",
			"\t\\$when = \\$4;",
			"\t$0",
			"}"
		]
	},
	"ssh_initial": {
		"description": "Fired when an SSH session is seen for the first time.",
		"prefix": "ssh_initial",
		"body": [
			"on ssh_initial {",
			"\t\\$session = \\$1;",
			"\t$0",
			"}"
		]
	},
	"ssh_input": {
		"description": "Fired when an input message is posted to an SSH console.",
		"prefix": "ssh_input",
		"body": [
			"on ssh_input {",
			"\t\\$session = \\$1;",
			"\t\\$user = \\$2;",
			"\t\\$message = \\$3;",
			"\t\\$when = \\$4;",
			"\t$0",
			"}"
		]
	},
	"ssh_output": {
		"description": "Fired when output is posted to an SSH console.",
		"prefix": "ssh_output",
		"body": [
			"on ssh_output {",
			"\t\\$session = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"ssh_output_alt": {
		"description": "Fired when (alternate) output is posted to an SSH console. What makes for alternate output? It's just different presentation from normal output.",
		"prefix": "ssh_output_alt",
		"body": [
			"on ssh_output_alt {",
			"\t\\$session = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"ssh_tasked": {
		"description": "Fired when a task acknowledgement is posted to an SSH console.",
		"prefix": "ssh_tasked",
		"body": [
			"on ssh_tasked {",
			"\t\\$session = \\$1;",
			"\t\\$message = \\$2;",
			"\t\\$when = \\$3;",
			"\t$0",
			"}"
		]
	},
	"web_hit": {
		"description": "Fired when there's a new hit on Cobalt Strike's web server.",
		"prefix": "web_hit",
		"body": [
			"on web_hit {",
			"\t\\$method = \\$1;",
			"\t\\$requestUri = \\$2;",
			"\t\\$visitorAddress = \\$3;",
			"\t\\$visitorUserAgent = \\$4;",
			"\t\\$serverResponse = \\$5;",
			"\t\\$responseSize = \\$6;",
			"\t\\$description = \\$7;",
			"\t\\%parameters = \\$8;",
			"\t\\$when = \\$9;",
			"\t$0",
			"}"
		]
	},
	"agApplications": {
		"description": "Pull information from the applications model.",
		"prefix": "agApplications",
		"body": [
			"agApplications($0${1:model})"
		]
	},
	"agC2info": {
		"description": "Pull information from the c2info model.",
		"prefix": "agC2info",
		"body": [
			"agC2info($0${1:model})"
		]
	},
	"agCredentials": {
		"description": "Pull information from the credentials model",
		"prefix": "agCredentials",
		"body": [
			"agCredentials($0${1:model})"
		]
	},
	"agServices": {
		"description": "Pull information from the services model",
		"prefix": "agServices",
		"body": [
			"agServices($0${1:model})"
		]
	},
	"agSessions": {
		"description": "Pull information from the sessions model",
		"prefix": "agSessions",
		"body": [
			"agSessions($0${1:model})"
		]
	},
	"agTargets": {
		"description": "Pull information from the targets model.",
		"prefix": "agTargets",
		"body": [
			"agTargets($0${1:model})"
		]
	},
	"agTokens": {
		"description": "Pull information from the phishing tokens model.",
		"prefix": "agTokens",
		"body": [
			"agTokens($0${1:model})"
		]
	},
	"attack_describe": {
		"description": "Maps a MITRE ATT&CK tactic ID to its longer description.",
		"prefix": "attack_describe",
		"body": [
			"attack_describe($0${1:tactic})"
		]
	},
	"attack_detect": {
		"description": "Maps a MITRE ATT&CK tactic ID to its detection strategy",
		"prefix": "attack_detect",
		"body": [
			"attack_detect($0${1:tactic})"
		]
	},
	"attack_mitigate": {
		"description": "Maps a MITRE ATT&CK tactic ID to its mitigation strategy",
		"prefix": "attack_mitigate",
		"body": [
			"attack_mitigate($0${1:tactic})"
		]
	},
	"attack_name": {
		"description": "Maps a MITRE ATT&CK tactic ID to its short name.",
		"prefix": "attack_name",
		"body": [
			"attack_name($0${1:tactic})"
		]
	},
	"attack_tactics": {
		"description": "An array of MITRE ATT&CK tactics known to Cobalt Strike.",
		"prefix": "attack_tactics",
		"body": [
			"attack_tactics()"
		]
	},
	"attack_url": {
		"description": "Maps a MITRE ATT&CK tactic ID to the URL where you can learn more.",
		"prefix": "attack_url",
		"body": [
			"attack_url($0${1:tactic})"
		]
	},
	"bookmark": {
		"description": "Define a bookmark [PDF document only]",
		"prefix": "bookmark",
		"body": [
			"bookmark($0${1:name}, [${2:child}])"
		]
	},
	"br": {
		"description": "Print a line-break.",
		"prefix": "br",
		"body": [
			"br()"
		]
	},
	"describe": {
		"description": "Set a description for a report.",
		"prefix": "describe",
		"body": [
			"describe($0${1:report}, ${2:description})"
		]
	},
	"h1": {
		"description": "Prints a title heading.",
		"prefix": "h1",
		"body": [
			"h1($0${1:title})"
		]
	},
	"h2": {
		"description": "Prints a sub-title heading.",
		"prefix": "h2",
		"body": [
			"h2($0${1:title})"
		]
	},
	"h3": {
		"description": "Prints a sub-sub-title heading.",
		"prefix": "h3",
		"body": [
			"h3($0${1:title})"
		]
	},
	"h4": {
		"description": "Prints a sub-sub-sub-title heading.",
		"prefix": "h4",
		"body": [
			"h4($0${1:title})"
		]
	},
	"kvtable": {
		"description": "Prints a table with key/value pairs.",
		"prefix": "kvtable",
		"body": [
			"kvtable($0${1:dictionary})"
		]
	},
	"landscape": {
		"description": "Changes the orientation of this document to landscape.",
		"prefix": "landscape",
		"body": [
			"landscape()"
		]
	},
	"layout": {
		"description": "Prints a table with no borders and no column headers.",
		"prefix": "layout",
		"body": [
			"layout($0${1:columnNames}, ${2:columnWidths}, ${3:rows})"
		]
	},
	"list_unordered": {
		"description": "Prints an unordered list",
		"prefix": "list_unordered",
		"body": [
			"list_unordered($0${1:bulletpoints})"
		]
	},
	"nobreak": {
		"description": "Group report elements together without a line break.",
		"prefix": "nobreak",
		"body": [
			"nobreak({",
			"\t$0",
			"});"
		]
	},
	"output": {
		"description": "Print elements against a grey backdrop. Line-breaks are preserved.",
		"prefix": "output",
		"body": [
			"output({",
			"\t$0",
			"});"
		]
	},
	"p": {
		"description": "Prints a paragraph of text.",
		"prefix": "p",
		"body": [
			"p($0${1:text})"
		]
	},
	"p_formatted": {
		"description": "Prints a paragraph of text with some format preservation.",
		"prefix": "p_formatted",
		"body": [
			"p_formatted($0${1:text})"
		]
	},
	"table": {
		"description": "Prints a table",
		"prefix": "table",
		"body": [
			"table($0${1:columnNames}, ${2:columnWidths}, ${3:rows})"
		]
	},
	"ts": {
		"description": "Prints a time/date stamp in italics.",
		"prefix": "ts",
		"body": [
			"ts()"
		]
	},
	"pe_insert_rich_header": {
		"description": "Insert rich header data into Beacon DLL Content. If there is existing rich header information, it will be replaced.",
		"prefix": "pe_insert_rich_header",
		"body": [
			"pe_insert_rich_header($0${1:temp_dll}{2:rich_heade})"
		]
	},
	"pe_mask": {
		"description": "Mask data in the Beacon DLL Content based on position and length.",
		"prefix": "pe_mask",
		"body": [
			"pe_mask($0${1:dll}{2:start},{3:length},{4:mask_key})"
		]
	},
	"pe_mask_section": {
		"description": "Mask data in the Beacon DLL Content based on position and length.",
		"prefix": "pe_mask_section",
		"body": [
			"pe_mask_section($0${1:dll}{2:section},{3:mask_key})"
		]
	},
	"pe_mask_string": {
		"description": "Mask a string in the Beacon DLL Content based on position.",
		"prefix": "pe_mask_string",
		"body": [
			"pe_mask_string($0${1:dll}{2:start},{3:mask_key})"
		]
	},
	"pe_patch_code": {
		"description": "Patch code in the Beacon DLL Content based on find/replace in .text section.",
		"prefix": "pe_patch_code",
		"body": [
			"pe_patch_code($0${1:dll}{2:byte_array},{3:resolved_offset})"
		]
	},
	"pe_remove_rich_header": {
		"description": "Remove the rich header from Beacon DLL Content.",
		"prefix": "pe_remove_rich_header",
		"body": [
			"pe_remove_rich_header($0${1:dll})"
		]
	},
	"pe_set_compile_time_with_long": {
		"description": "Set the compile time in the Beacon DLL Content.",
		"prefix": "pe_set_compile_time_with_long",
		"body": [
			"pe_set_compile_time_with_long($0${1:dll},{2:date})"
		]
	},
	"pe_set_compile_time_with_string": {
		"description": "Set the compile time in the Beacon DLL Content.",
		"prefix": "pe_set_compile_time_with_string",
		"body": [
			"pe_set_compile_time_with_string($0${1:dll},{2:time})"
		]
	},
	"pe_set_export_name": {
		"description": "Set the export name in the Beacon DLL Content.",
		"prefix": "pe_set_export_name",
		"body": [
			"pe_set_export_name($0${1:dll},{2:exportname})"
		]
	},
	"pe_set_long": {
		"description": "Places a long value at a specified location.",
		"prefix": "pe_set_long",
		"body": [
			"pe_set_long($0${1:dll},{2:location},{3:value})"
		]
	},
	"pe_set_short": {
		"description": "Places a short value at a specified location.",
		"prefix": "pe_set_short",
		"body": [
			"pe_set_short($0${1:dll},{2:location},{3:value})"
		]
	},
	"pe_set_string": {
		"description": "Places a string value at a specified location.",
		"prefix": "pe_set_string",
		"body": [
			"pe_set_string($0${1:dll},{2:location},{3:string})"
		]
	},
	"pe_set_stringz": {
		"description": "Places a string value at a specified location and adds a zero terminator.",
		"prefix": "pe_set_stringz",
		"body": [
			"pe_set_stringz($0${1:dll},{2:location},{3:string})"
		]
	},
	"pe_set_value_at": {
		"description": "Sets a long value based on the location resolved by a name from the PE Map (see pedump).",
		"prefix": "pe_set_value_at",
		"body": [
			"pe_set_value_at($0${1:dll},{2:location},{3:value})"
		]
	},
	"pe_stomp": {
		"description": "Set a string to null characters. Start at a specified location and sets all characters to null until a null string terminator is reached.",
		"prefix": "pe_stomp",
		"body": [
			"pe_set_value_at($0${1:dll},{2:location})"
		]
	},
	"pe_update_checksum": {
		"description": "Update the checksum in the Beacon DLL Content.",
		"prefix": "pe_update_checksum",
		"body": [
			"pe_set_value_at($0${1:dll})"
		]
	}
	,
	"pedump": {
		"description": "Parse an executable Beacon into a map of the PE Header information. The parsed information can be used for research or programmatically to make changes to the Beacon.",
		"prefix": "pedump",
		"body": [
			"pedump($0${1:dll})"
		]
	}
}
